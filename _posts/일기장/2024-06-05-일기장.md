---
layout: post
title: 회의록
category: 일기
---

---
{: data-content=" 개념 "}



**(아직 정리중이에요!)**

# Principles of reliable data transfer

---

- `TCP` 핵심
- reliable service implementation

![스크린샷 2023-04-21 오후 3.23.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/801ccfe4-f272-42dc-a240-6f904309a658/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.23.45.png)

- app layer에서 신뢰를 요구하지만
- net layer에서 신뢰를 제공하지 못하는 상황 (best-effort)

⇒ transport layer에서 신뢰를 제공해야함 (TCP)

- **unreliable channel**
    - sender, receiver do not know the state of each other
    - **커튼**이 쳐진 채로 상대방을 인식한다

## Reliable data transfer protocol (rdt)

### interfaces

![스크린샷 2023-04-21 오후 3.27.23.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a65c615-d95f-487a-9587-5f298f9f6fb1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.27.23.png)

- `rdt_send()`
    - called from above : passed data to receiver
- **`udt**_send()`
    - called by rdt : transfer packet over **unreliable**
    - header 붙임
- `rdt_rcv()`
    - called when packet arrives
- `deliver_data()`
    - called by rdt : deliver data to upper layer

### getting started

![스크린샷 2023-04-21 오후 3.33.30.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68871678-4ab2-4793-ab08-cbd011256d14/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.33.30.png)

- **uni**directional data transfer
    - sender가 정해져 있음
    - control info in both directions
- finite state machines (FSM)
    - specify sender / receiver

### rdt2.0

---

- **sender**
    
    ![스크린샷 2023-04-21 오후 3.36.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/987f69a2-dfd8-4de6-86d0-6de4daf18279/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.36.02.png)
    
    - if `ACK` received
        
        → **no** action
        
        → wait for call from above
        
    - if `NAK` received
        
        → **재전송** : udt_send(sndpkt)
        
        → wait for ACK/NAK
        

---

- **receiver**
    
    ![스크린샷 2023-04-21 오후 3.38.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2c05dcd7-f6e3-4f9e-a540-8c072d219539/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.38.27.png)
    
    - if `corrupt`
        
        → udt_send(`NAK`)
        
    - if `not corrupt`
        
        → extract & deliver data
        
        → udt_send(`ACK`)
        

---

### rdt2.0 has fatal flow!

- what happens if **ACK/NAK corrupted** ?
    - `재전송`하는 수밖에 없음
    - possible `duplicate` : 같은 내용이 2번 보내졌다고 착각 가능 → 처리 기능 필요
- handling **duplicates**
    - adds `seq#` to each pkt
    - packet에 번호를 부여해서 보냄
    - recevier discards duplicate pkt

<aside>
💡 **Stop and Wait** (protocol)

- sender sends one packet (`stop`)
- then `waits` for receiver response
</aside>

- sender가 pkt을 보내고 stop → **ACK**가 오기 전까지 wait
- 양쪽의 **sync**가 맞음 (`동기화`)
- BUT 성능상 문제 발생 가능

---

### rdt2.1 : handling garbled ACK/NAKs

- stop and wait
- seq# : `0`, `1`
    - 2개면 충분, 구분만 가능하면 됨

---

- **sender**
    
    ![스크린샷 2023-04-21 오후 3.53.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4535016f-80de-49a9-b7a7-c1d04ceb89b5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.53.06.png)
    
    - `corrupt` || `NAK`
        
        → **재전송**
        
        → wait for ACK/NAK (same seq#)
        
    - `not corrupt` && `ACK`
        
        → **no** action
        
        → 상위 계층이 보내는 다음 pkt 기다림 (diff seq#)
        

---

- **receiver**
    
    ![스크린샷 2023-04-21 오후 3.58.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8bbbf28-6a23-4fb0-8a9f-73259e9c8012/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.58.24.png)
    
    - if `corrupt`
        
        → udt_send(`NAK`)
        
    - if `not corrupt` && `diff seq#`
        - 제대로 도착하지만 seq# **다름** (또보냈네? → 무시)
            - **그러나 같은 seq# 계속 기다림 (동기화 때문)**
        
        → udt_send(`ACK`)
        
    - if `not corrupt` && `same seq#`
        
        → udt_send(ACK)
        
        → wait for diff seq# from below
        

---

### rdt2.1 : discussion

- **sender**
    - 2 `seq#` added : 0, 1
    - check if **ACK/NAK corrupted**
    - `twice` as many `states`
        - remember **seq #**

- **receiver**
    - check if `duplicate` pkt
        - seq #
    - cannot know
    if last ACK/NAK received OK

---

### rdt2.2 : NAK-free protocol

- ACK(+num)만 쓰자
    - NAK의 역할도 함
- sends `ACK` + `seq#` of pkt being **ACKed**
    
    ex) ACK0 : 0까지 잘 받았다
    
- **duplicate ACK** ← same action as NAK (제대로 못받았으니까 다시 보내줘)
    - `retransmit` current pkt

---

- **sender / receiver**
    
    ![스크린샷 2023-04-21 오후 4.13.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03c6bcd1-de0b-4d25-916d-90a6a1c0fe11/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.13.08.png)
    
    ---
    
    - (sender) while waiting for ACK`0`
        1. receives `corrupt` || ACK`1` → `0` pkt 다시 보냄
        2. receives `not corrupt` && ACK`0` → **no** action (잘받음)
    - (receiver) while waiting for `0` from below
        1. receives `not corrupt` && `same seq` → send ACK`0`, extract & deliver (정상)
        2. receives `corrupt` || `diff deq#` → 재전송 (1까지는 잘받음 ACK1, 비정상)

---

### rdt3.0 : channels with erorrs and loss

- 이전 : unreliable → pkt 훼손 가능
- can also **lose** packets
    - 주로 tail drop
    - `data`, `ACK`s
- waits reasonable time for ACK
    - 충분히 올 만한 시간, 이때까지 ACK 안 오면 문제가 생겼다고 판단
    
    → 재전송
    
    - if just delayed : duplicated, BUT seq# can handle
        
        ![스크린샷 2023-04-21 오후 4.25.03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c121528a-890e-441a-b7fe-ecf194135fbe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.25.03.png)
        
- use countdown **timer**

---

- **sender**
- **정상적**으로 잘 전송된 경우
    
    ![스크린샷 2023-04-21 오후 4.25.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd13685d-4ed2-4068-a9b2-a902c1305322/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.25.37.png)
    
    - `start_timer` : countdown timer
        - starts when sending data
    - `stop_timer`
        - 도착한 시점에 timer 멈춤
        - expire되지 않도록
- **timeout**이 발생한 경우
    
    ![스크린샷 2023-04-21 오후 4.26.37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16380af2-385b-4cd0-b1be-eb06cddb0d2d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.26.37.png)
    
    - if `timeout`
        - 만들어놓은 pkt 재전송
        - `start_timer`
    - if `corrupt` || ACK(`diff seq#`)
        - ACK라고 판정하면 안됨
        - 아무것도 하지 않고 `대기`
    - 응답을 모두 받은 상태
        - BUT timeout 재전송으로 인해 **duplicate**가 발생한 경우
        
        → `무시`
        

---

- `packet` loss

![스크린샷 2023-04-21 오후 4.34.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc5245ba-8bf0-403a-880d-29b192caac7c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.34.27.png)

(sender)

- pkt1 loss
    
    → **timeout**
    
    → resend pkt1
    
- 문제를 잘 해결함
- `ACK` loss

![스크린샷 2023-04-21 오후 4.36.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77945108-7920-4452-94aa-5bc54a793722/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.36.36.png)

(receiver)

- rcv pkt1
- 상위에 deliver

(sender)

- ack1 loss
    
    → **timeout**
    
    → resend pkt1
    

(receiver)

- rcv pkt1
    
    → detect **duplicate**
    
    → 상위에 deliver x
    
- `premature` timeout / delayed ACK
- timeout이 너무 일찍 발생
    
    ![스크린샷 2023-04-21 오후 4.45.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d91302fc-97cc-4c3e-bc4e-d81adc062a4e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.45.35.png)
    

![스크린샷 2023-04-21 오후 4.41.18.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f236891f-6aa4-4f9a-856f-441266730ea1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.41.18.png)

(receiver)

- send ack1 (잘보냄)

(sender)

→ **timeout**

→ resend pkt1

(receiver)

- rcv pkt1 (detect duplicate)
- send ack1

(sender)

- rcv ack1 (**delayed** ACK)
- send pkt0
- rcv ack1
    
    → ignore
    

(이미 처리함, pkt0 응답 기다리는 중)

⇒ msg **corrupt** & **loss** `둘 다 처리` 가능 !!

# Performance of rdt3.0 : stop-and-wait operation

---

- 실제론 사용x (성능 때문)
- $U_{sender}$ : **utilization**
    
    ![스크린샷 2023-04-21 오후 4.47.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d67346f-32ff-4e7f-ac24-e7f559ee15db/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.47.20.png)
    

![스크린샷 2023-04-21 오후 4.49.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3062eb4-53cf-4f67-8d77-d522f0e20b9b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.49.36.png)

<aside>
💡 **Packet delay**

---

![스크린샷 2024-06-03 12.32.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/98c015d1-def8-4399-931a-47453151ae6d/3880cee1-8c72-44fb-916d-3a801a8bf1d1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-03_12.32.15.png)

</aside>

- 실제로 sender가 일하는 시간 : $L/R$
- 전체 걸리는 시간 : $RTT + L/R$
    - ACK는 1줄 : 크기가 작기 때문

![스크린샷 2023-04-21 오후 4.57.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa309684-e818-4cc3-8f20-cb72cd156c1d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.57.28.png)

→ 매우 낮은 utilization

→ sender가 활용을 잘 못하고 있음 (보낼 data는 많은데..)

→ **쓰지 마세요! (stinks)**

# Performance of rdt3.0 : pipelined operation

---

- stop-and-wait 버리자
- `pipelining`
    - sender allows **multiple**, **in-filght**
    - 다 들어오기 전에 ACK 보내기 시작
        - 어떤 pkt에 대한 ACK인지 구별 필요 (`seq#`)
        - 받은 pkt 보관하는 `buffer` 필요 (sender, receiver 모두)
            
            (ACK 받기 전까지 보관)
            

![스크린샷 2023-04-21 오후 4.57.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6157b422-cd29-49b7-af18-d934bea657dd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.57.06.png)

- 한번에 packet 3개 보내기
- 3-packet pipelining → utilization increased (x3)
- `pipelining 개수`에 따라 utilization 더 커질 수도 있음

<aside>
💡 실제 TCP는 `Go-Back-N`과 `Selective Repeat` 장점으로 구성

---

- Go-Back-N
    
    ![스크린샷 2023-04-21 오후 5.07.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d87c8495-a363-424b-9b97-1330d46e8f77/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.07.42.png)
    
- Selective Repeat
    
    ![스크린샷 2023-04-21 오후 5.34.11.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6916c10c-8384-47ab-8ee5-9ec1fb2b2fdb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-21_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.34.11.png)
    
</aside>